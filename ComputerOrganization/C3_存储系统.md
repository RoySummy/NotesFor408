# 存储系统

## 基本概念

![image-20210720223552453](Images/image-20210720223552453.png)

### 层次结构

![image-20210720223147815](Images/image-20210720223147815.png)

### 存储器分类

1. 层次

   ![image-20210720223214105](Images/image-20210720223214105.png)

2. 存储介质

   1. 半导体存储器	主存、Cache
   2. 磁表面存储器    磁盘、磁带
   3. 光存储器          光盘

3. 存取方式

   ![image-20210720223410469](Images/image-20210720223410469.png)

4. 信息的可更改性

   ![image-20210720223444845](Images/image-20210720223444845.png)

5. 信息的可保存性

   ![image-20210720223506012](Images/image-20210720223506012.png)

### 存储器性能指标

![image-20210720223524940](Images/image-20210720223524940.png)

## 主存储器的基本组成

![image-20210724202321503](Images/image-20210724202321503.png)

### 基本元件

![image-20210724202725890](Images/image-20210724202725890.png)

### 结构

![image-20210724202953998](Images/image-20210724202953998.png)

> 译码器的工作原理是：在MAR中的数据对应的存储单元的那条红线(==字选择线==)中输入高电平，然后所有MOS管就通了，然后数据就能顺着绿色的线(==数据线==)到达MDR中
>
> $\overline{CS}$和$\overline{CE}$的作用就是：当这条线中是低电平的时候这个存储芯片是可用的。

![image-20210724203410044](Images/image-20210724203410044.png)

> 这里的译码驱动指的是两个器件，一个是译码器，另一个是驱动器，驱动器起到对译码器中的信号进行放大，让信号更稳定的作用。

### 寻址

![image-20210724203516663](Images/image-20210724203516663.png)

> 字地址转换成字节地址只需要将地址左移两位就可以了

## DRAM 和 SRAM

### 对比🚩

![image-20210724210135214](Images/image-20210724210135214.png)

> ==核心区别：存储元不同==
>
> DRAM使用==栅极电容==存储信息
>
> SRAM使用==双稳态触发器==存储信息

![image-20210724210419955](Images/image-20210724210419955.png)

> 栅极电容：每个存储元制造成本更低，集成度高， 功耗低
>
> 双稳态触发器：每个存储元制造成本更高，集成度低， 功耗大

### DRAM的刷新

1. 为什么刷新

   电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失。所以需要刷新(充电)

   而对于双稳态触发器而言，只要不断电，触发器的状态就不会改变

2. 多久刷新一次

   刷新周期：一般为2ms

3. 每次刷新多少存储单元

   以行为单位，每次刷新一行存储单元。

   1. 为什么使用行列存储？

      减少选通线的数量

      ![image-20210724210859208](Images/image-20210724210859208.png)

      比如有$2^8$个存储单元，如果使用一个译码器上挂接所有选通线的策略，就需要$2^8$条线，而如果使用行列地址的话，将8个地址位拆分成前4位和后4位，每个译码器只需要接$2^4$个线，工程上实现比较简单

4. 如何刷新

   有硬件支持，读出一行的信息后重新写入，占用1个读/写周期

5. 什么时候刷新

   ![image-20210724211250746](Images/image-20210724211250746.png)
   
   > 分散刷新==不存在死时间==

### DRAM的地址线复用技术

由于DRAM的存储单元个数很多，因此所需要的地址线也就很多，如果行列地址线都接在一起的话，接在一个器件上的线就很多，所以设置两个缓存，将地址拆成两部分，第一次传送行地址，第二次传送列地址，从而使地址线的个数减少到$\frac{n}{2}$

![image-20210724211538393](Images/image-20210724211538393.png)

## ROM

![image-20210724214313262](Images/image-20210724214313262.png)

###　各种ROM

![image-20210724214428971](Images/image-20210724214428971.png)

### 计算机里的重要ROM

![image-20210724214627537](Images/image-20210724214627537.png)

## 存储器与CPU的连接

![image-20210724222341744](Images/image-20210724222341744.png)

![image-20210724222433098](Images/image-20210724222433098.png)

![image-20210724222446588](Images/image-20210724222446588.png)

![image-20210724222504916](Images/image-20210724222504916.png)

### 位扩展

![image-20210724222526938](Images/image-20210724222526938.png)

每一条数据总线连接一个芯片，能够解决数据总线条数大于存储芯片字长的问题

![image-20210724222635805](Images/image-20210724222635805.png)

### 字扩展

#### 线选法

![image-20210724222715255](Images/image-20210724222715255.png)

> 8K$\times$8位的芯片里面共有$2^{13}$个存储单元，只需要13个地址线就可以表示所有的存储单元。于是13~15三条线就没用了。
>
> 此时将$A_{13}、A_{14}$分别接到第一个和第二个芯片上，当$A_{13}$为1，$A_{14}$为0时，第一个芯片起作用，反过来就是第二个芯片起作用，这样就达到了尽可能利用地址线的目的
>
> 但是这种扩展方法有问题，如果两条地址线都为1，传送到MDR的数据还是会发生冲突。从而就导致了只有10和01两种状态可以使用，也就产生了==内存地址不连续==的问题

![image-20210724223205179](Images/image-20210724223205179.png)

解决方法：

#### 使用译码器

![image-20210724223401392](Images/image-20210724223401392.png)

将$A_{13}$的数据连到两个芯片上，但是有一个上面取非，这样当信号是1的时候第一块起作用，信号是0的时候第二块起作用。

![image-20210724223632079](Images/image-20210724223632079.png)

> 这里的1-2译码器中的1和2代表1种输入信号，两种输出信号
>
> 同样也可以是2-4、3-8

![image-20210724223646857](Images/image-20210724223646857.png)

考试的时候会出现以下这种情况

![image-20210724223722922](Images/image-20210724223722922.png)

此时$A_{14}$不起作用，所以就导致了每个芯片的最低地址和最高地址发生了变化，不同的地址可能会对应相同的存储单元。

![image-20210724223832088](Images/image-20210724223832088.png)

#### 字位同时扩展

![image-20210724223857306](Images/image-20210724223857306.png)

## 译码器

![image-20210724223921295](Images/image-20210724223921295.png)

右边的EN为0的时候，输出的电信号全部为1，这时候就没有芯片会起作用

![image-20210724224045190](Images/image-20210724224045190.png)

![image-20210724224101150](Images/image-20210724224101150.png)

## 双端口RAM和多模块存储器

![image-20210730113700109](Images/image-20210730113700109.png)

![image-20210730113636526](Images/image-20210730113636526.png)

### 双端口RAM

![image-20210730113742358](Images/image-20210730113742358.png)

### 多模块存储器

#### 多体并行存储器

高位交叉编址：使用地址高位来区分不同的存储体

低位交叉编址：使用地址低位来区分不同的存储体

![image-20210730113955446](Images/image-20210730113955446.png)

![image-20210730114017021](Images/image-20210730114017021.png)

![image-20210730114050444](Images/image-20210730114050444.png)

#### 单体多字存储器

![image-20210730114122329](Images/image-20210730114122329.png)

## Cache基本原理基本概念

![image-20210730121805403](Images/image-20210730121805403.png)

### 局部性原理

![image-20210730121839209](Images/image-20210730121839209.png)

### 性能🚩

![image-20210730121909015](Images/image-20210730121909015.png)

![image-20210730121926738](Images/image-20210730121926738.png)

### 块的概念

基于局部性原理想要把目前访问地址周围的部分数据放到Cache中。如何界定==“周围”==？

![image-20210730122105151](Images/image-20210730122105151.png)

> 【注】：每次被访问的主存块， 一定会被立即调入Cache

## Cache-主存映射方式

![image-20210730124140415](Images/image-20210730124140415.png)

### 全相联映射

![image-20210730124233165](Images/image-20210730124233165.png)

### 直接映射

![image-20210730124630223](Images/image-20210730124630223.png)

### 组相联映射

![image-20210730124648752](Images/image-20210730124648752.png)