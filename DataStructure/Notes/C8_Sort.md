# 排序

## 插入排序

![](Images/2021-06-04-22-07-44.png)

```c++
//空间复杂度 O(1)
//时间复杂度 O(n^2)
//算法稳定性：稳定

void InsertSort(int A[], int n)
{
    int i,j,temp;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			for ( j = i - 1; j >= 0 && A[j] > temp; j--)
				A[j + 1] = A[j];
			A[j + 1] = temp;
		}
	}
}

//带哨兵的存储模式，A[0]不存储实际数据，用于保存临时变量，判断条件就减少了
void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 2; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			A[0] = A[i];
			for (j = i - 1; A[0] < A[j]; j--)
				A[j + 1] = A[j];
			A[j + 1] = A[0];
		}
	}
}
```

![](Images/2021-06-04-21-50-03.png)
![](Images/2021-06-04-21-50-38.png)

时间复杂度主要来自比对关键字、移动元素，若有n个元素，则需要n-1趟处理

### 优化

在向前查找插入位置的时候，因为前面的序列已经是有序的，所以可以使用二分查找来进行优化，

需要注意的是，这里的二分查找退出条件只有li<hi //保持算法的稳定性
![](Images/2021-06-04-21-52-03.png)

```c++
//时间复杂度 O(n^2)
//空间复杂度 O(1)
//稳定性： 稳定

void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			int li = 0, hi = i - 1;
			while (li <= hi)
			{
				int mi = (li + hi) / 2;
				if (A[mi] > temp)hi = mi - 1;
				else li = mi + 1;
			}
			for (j = i - 1; j >= li; j--)
				A[j + 1] = A[j];
			A[li] = temp;
		}
	}
}
```

## 希尔排序

算法思想：先追求表中元素部分有序，再逐渐逼近全局有序

![](Images/2021-06-04-22-36-24.png)

排序过程：先将待排序表分割成若⼲形如 $L[i, i + d, i + 2d,\cdots, i + kd]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量d，重复上述过程，直到d=1为⽌。

![](Images/2021-06-04-22-37-58.png)
![](Images/2021-06-04-22-38-12.png)
![](Images/2021-06-04-22-38-29.png)
![](Images/2021-06-04-22-38-53.png)
![](Images/2021-06-04-22-39-07.png)
![](Images/2021-06-04-22-39-19.png)
![](Images/2021-06-04-22-39-27.png)
![](Images/2021-06-04-22-39-39.png)
![](Images/2021-06-04-22-39-49.png)
![](Images/2021-06-04-22-39-57.png)

```c++
void ShellSort(int A[], int n)
{
	int d, i, j;
	for (d = n / 2; d >= 1; d /= 2)
	{
		for (i = d + 1; i <= n; i++)	//这里实现的是各个子表交替执行，见下图模拟
		{
			if (A[i] < A[i - d])
			{
				A[0] = A[i];
				for (j = i - d; j > 0 && A[0] < A[j]; j -= d)
					A[j + d] = A[j];
				A[j + d] = A[0];
			}
		}
	}
}
```
第一轮：
![第一轮](Images/2021-06-04-22-45-20.png)
第二轮：
![](Images/2021-06-04-22-45-47.png)

```c++
//另一种写法，每次都先将一个子表插入排序完毕之后再加工下一个子表

/* 解释：考虑到增量d会将整个序列分成d个子序列。比如数组{1,2,3,4,5,6,7,8}长度为8，增量为4
 * 此时子表分别为 {1,5}, {2,6}, {3,7}, {4,8}
 * 共有4个子表，而进行希尔排序的时候是从第一个子表的最后一个元素开始执行插入排序的
 * 例如第一个子表，我们会从元素5开始往前进行比较....
 * 
 * 知道了这个之后假设这样一个序列{20,30,10,50,60,40,70,80}
 * 假设现在的d为2,那么分成的子表就是{20,10,60,70}, {30,50,40,80}
 *
 * 第一轮循环k=0，i=d+0=d=2，也就是指向10这个元素，然后向前进行比较，符合交换的条件，
 * 子表变为{10,20,60,70}
 * 然后执行i+=d，在之前的代码中子表交错执行是i++，这里是i+=d，
 * 也就是i现在指向了60这个元素，然后向前比较，不符合交换条件...
 *
 * 第二轮循环k=1，i=d+1=3，也就是指向50这个元素...依此类推。
 */

void ShellSort(vector<int>& nums)
{
	for (int d = nums.size() / 2; d > 0; d /= 2)
	{
		for (int k = 0; k < d; k++)	//这里的k代表的就是进行到第k+1个子表
		{
			for (int i = d + k; i < nums.size(); i += d)
			{
				if (nums[i] < nums[i - d])
				{
					int j, temp = nums[i];
					for (j = i - d; j >= 0 && nums[j] > temp; j -= d)
						nums[j + d] = nums[j];
					nums[j + d] = temp;
				}
			}
		}
	}
}
```



### 性能分析

空间复杂度：O(1)

时间复杂度：和增量序列 d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度

最坏时间复杂度为 O(n^2^)，当n在某个范围内时，可达O(n^1.3^)

稳定性：不稳定

![](Images/2021-06-04-22-47-57.png)

仅适用于顺序表

## 冒泡排序

![](Images/2021-06-05-20-08-31.png)

```c++
//空间复杂度 O(1)
//时间复杂度：
//	最好：序列有序，O(n)
//	最坏：序列逆序，O(n^2)
//	平均：O(n^2)
//稳定性：稳定
//链表也可用

void BubbleSort(int A[], int len)
{
	//只需执行len-1趟，最小的len-1个元素放在合适的位置，最后一个元素自然就是最大的
	for (int i = 0; i < len - 1; i++)
	{
		bool flag = false;			//如果出现没有交换的情况，证明序列已经有序
		for (int j = len - 1; j > i; j--)
		{
			if (A[j - 1] > A[j])	//仅在严格大于时交换，保证算法稳定性
			{
				Swap(A[j - 1], A[j]);
				flag = true;
			}
		}
		if (!flag) return;
	}
}
```

## 快速排序

![](Images/2021-06-05-20-46-55.png)

思想：在待排序数组中取一段，把这段的第一个元素当作pivot值，然后想办法把这段中所有小于支点值的元素都挪到支点值的左边，把所有大于支点值的元素都挪到支点值的右边，这样，支点值就处在了它最终该在的位置----这一步成为”分区“(partition)。然后，把支点值以左的元素和支点值以右的元素各看作一段，继续(递归)进行分区操作，直到没有更小的段可以操作。这样，被选取的这段就排好序了。当然，如果选取的这段时整个序列，那么这个序列就排好序了。

```c++
//A数组中以low为起点，high为终点的序列，将low所指元素指定为基准，
//最终达到基准左边全部小于基准元素，基准右边全部大于基准元素，并返回基准元素所在位置
int Partition(int A[], int low, int high)	
{
	int pivot = A[low];
	while (low < high)
	{
		while (low < high && A[high] >= pivot)
			high--;
		A[low] = A[high];
		while (low < high && A[low] <= pivot)
			low++;
		A[high] = A[low];
	}
	A[low] = pivot;
	return low;
}

void QuickSort(int A[], int low, int high)
{
	if (low < high)
	{
		int pivotPos = Partition(A, low, high);
		QuickSort(A, low, pivotPos - 1);
		QuickSort(A, pivotPos + 1, high);
	}
}
```

## 选择排序

![](Images/2021-06-05-21-06-02.png)

每轮选择最小的元素，放在本轮的最前面。

```c++
//空间复杂度：O(1)
//时间复杂度：
//	最坏=最好=平均=O(n^2)
//稳定性：不稳定
void SelectSort(int A[], int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		int min = i;
		for (int j = i + 1; j < n; j++)
			if (A[j] < A[min]) min = j;
		if (min != i) Swap(A[i], A[min]);
	}
}
```

## 堆排序

![](Images/2021-06-05-22-20-04.png)

### 堆：

1. 忽略数组第一个元素(索引为0的元素)
2. 从索引为1的元素开始，把每个元素都看作是二叉树上的一个结点
3. 父子结点之间的关系：
    1. 当父结点的索引为i，左孩子为2i，右孩子为2i+1
    2. 当子结点索引为i，父结点索引为$\lfloor i/2\rfloor$
4. 可以把堆视作一棵“完全二叉树”(complete binary tree)，而数组则是这棵完全二叉树逐层(广度优先)访问所产生的串行化结果。
5. 当约束了父子结点之间的大小关系之后，就能得到两种很重要的堆
    1. 大根堆：任何一个父结点的值都比其子结点(如果有)的值大-----主要用于堆排序
    2. 小根堆：任何一个父结点的值都比其子结点(如果有)的值小-----主要应用于优先队列

### 大根堆和小根堆的性质：

1. 排好升/降序的数组是大/小根堆，但大/小根堆化的数组不一定是排好升/降序的。
2. 大根堆的值一定是数组的最大值，而且是数组索引为1的值
3. 小根堆的值一定是数组的最小值，而且是数组索引为1的值
4. 大/小根堆知识约束了父结点与子结点之间的大小关系，左右孩子之间的大小关系并不一定
5. 与二叉排序树没有任何关系

当构造了一个大顶堆之后，就能使用“选择排序”，选取第一个元素，放在最后面这种方式来对序列进行排序了。
![](Images/2021-06-05-21-57-43.png)

### 建立大/小根堆

1. 写一个算法，把大/小的元素从根向叶子“下沉”
2. 以从尾(最后一个分支结点)到头的顺序，把数组里的每个元素“下沉”一遍

如果下沉的是较小的元素，最终得到的就是一个大根堆，反之得到的就是小根堆。

```c++
/// <summary>
/// 将以k为根的子树调整为大根堆
/// </summary>
/// <param name="A">整个数组</param>
/// <param name="k">根结点所在位置</param>
/// <param name="len">以根结点为起始，待调整序列的长度</param>
void HeadAdjust(int A[], int k, int len)
{
	A[0] = A[k];							//A[0]暂存子树根结点
	for (int i = 2 * k; i <= len; i *= 2)	//i指向的是以k为根结点的左孩子
	{
		//比较左孩子与右孩子的值，如果右孩子大，让i指向右孩子
		if (i < len && A[i] < A[i + 1])
			i++;
		if (A[0] >= A[i]) break;			//如果根更大，跳出循环
		else
		{
			A[k] = A[i];					//将子结点中更大者放在根处
			//因为交换之后该子树可能不符合大根堆的定义，以被交换的位置为根继续调整
			k = i;
		}
	}
	A[k] = A[0];							//将最开始的根放在应该“下沉”的最终位置
}

void BuildMaxHeap(int A[], int len)
{
	for (int i = len / 2; i > 0; i--)	//从后往前调整所有的非终端结点
		HeadAdjust(A, i, len);
}
```

### 排序：

将数组堆化之后就可以进行排序了，首先将根结点元素(最大)与最后一个元素进行交换，

此时最大的元素排在了最后面，前面的n-1个元素可能不再符合大根堆的条件，将其根结点进行“下沉”，

于是数组的第一个元素(索引为1)就变成了前n-1个元素中的最大元素，将其与第n-1个元素进行交换...依此类推，n-1个较大的元素都已经放置在合适的位置之后就完成了排序。

```c++
void HeapSort(int A[], int len)
{
	BuildMaxHeap(A, len);			//将数组“堆化”
	for (int i = len; i > 1; i--)	//共进行n-1趟
	{
		Swap(A[i], A[1]);			//交换当前堆中第一个元素与最后一个元素
		HeadAdjust(A, 1, i - 1);	//调整当前堆去掉最后一个元素之后的堆
	}
}
```
### 效率分析：
![](Images/2021-06-05-22-18-42.png)
![](Images/2021-06-05-22-18-56.png)
![](Images/2021-06-05-22-19-09.png)
![](Images/2021-06-05-22-19-25.png)
![](Images/2021-06-05-22-19-37.png)

稳定性：不稳定，反例: {1,2,2}

### 堆的插入与删除：

![](Images/2021-06-05-22-31-22.png)

以小顶堆为例：

#### 插入：

新元素放到表尾，与⽗节点对⽐， 若==新元素==⽐==⽗节点==更⼩，则将⼆者互换。新元素 就这样⼀路==“上升”==，直到⽆法继续上升为⽌

#### 删除：

被删除的元素==⽤堆底元素替代==，然后让该 元素不断==“下坠”==，直到⽆法下坠为⽌

