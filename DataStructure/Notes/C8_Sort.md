# 排序

## 插入排序

![](Images/2021-06-04-22-07-44.png)

```c++
//空间复杂度 O(1)
//时间复杂度 O(n^2)
//算法稳定性：稳定

void InsertSort(int A[], int n)
{
    int i,j,temp;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			for ( j = i - 1; j >= 0 && A[j] > temp; j--)
				A[j + 1] = A[j];
			A[j + 1] = temp;
		}
	}
}

//带哨兵的存储模式，A[0]不存储实际数据，用于保存临时变量，判断条件就减少了
void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 2; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			A[0] = A[i];
			for (j = i - 1; A[0] < A[j]; j--)
				A[j + 1] = A[j];
			A[j + 1] = A[0];
		}
	}
}
```

![](Images/2021-06-04-21-50-03.png)
![](Images/2021-06-04-21-50-38.png)

时间复杂度主要来自比对关键字、移动元素，若有n个元素，则需要n-1趟处理

### 优化

在向前查找插入位置的时候，因为前面的序列已经是有序的，所以可以使用二分查找来进行优化，

需要注意的是，这里的二分查找退出条件只有li<hi //保持算法的稳定性
![](Images/2021-06-04-21-52-03.png)

```c++
//时间复杂度 O(n^2)
//空间复杂度 O(1)
//稳定性： 稳定

void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			int li = 0, hi = i - 1;
			while (li <= hi)
			{
				int mi = (li + hi) / 2;
				if (A[mi] > temp)hi = mi - 1;
				else li = mi + 1;
			}
			for (j = i - 1; j >= li; j--)
				A[j + 1] = A[j];
			A[li] = temp;
		}
	}
}
```

## 希尔排序

算法思想：先追求表中元素部分有序，再逐渐逼近全局有序

![](Images/2021-06-04-22-36-24.png)

排序过程：先将待排序表分割成若⼲形如 $L[i, i + d, i + 2d,\cdots, i + kd]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量d，重复上述过程，直到d=1为⽌。

![](Images/2021-06-04-22-37-58.png)
![](Images/2021-06-04-22-38-12.png)
![](Images/2021-06-04-22-38-29.png)
![](Images/2021-06-04-22-38-53.png)
![](Images/2021-06-04-22-39-07.png)
![](Images/2021-06-04-22-39-19.png)
![](Images/2021-06-04-22-39-27.png)
![](Images/2021-06-04-22-39-39.png)
![](Images/2021-06-04-22-39-49.png)
![](Images/2021-06-04-22-39-57.png)

```c++
void ShellSort(int A[], int n)
{
	int d, i, j;
	for (d = n / 2; d >= 1; d /= 2)
	{
		for (i = d + 1; i <= n; i++)	//这里实现的是各个子表交替执行，见下图模拟
		{
			if (A[i] < A[i - d])
			{
				A[0] = A[i];
				for (j = i - d; j > 0 && A[0] < A[j]; j -= d)
					A[j + d] = A[j];
				A[j + d] = A[0];
			}
		}
	}
}
```
第一轮：
![第一轮](Images/2021-06-04-22-45-20.png)
第二轮：
![](Images/2021-06-04-22-45-47.png)

### 性能分析

空间复杂度：O(1)

时间复杂度：和增量序列 d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度

最坏时间复杂度为 O(n^2^)，当n在某个范围内时，可达O(n^1.3^)

稳定性：不稳定

![](Images/2021-06-04-22-47-57.png)

仅适用于顺序表