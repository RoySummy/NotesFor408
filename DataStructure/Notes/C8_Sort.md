# 排序

## 插入排序

![](Images/2021-06-04-22-07-44.png)

```c++
//空间复杂度 O(1)
//时间复杂度 O(n^2)
//算法稳定性：稳定

void InsertSort(int A[], int n)
{
    int i,j,temp;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			for ( j = i - 1; j >= 0 && A[j] > temp; j--)
				A[j + 1] = A[j];
			A[j + 1] = temp;
		}
	}
}

//带哨兵的存储模式，A[0]不存储实际数据，用于保存临时变量，判断条件就减少了
void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 2; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			A[0] = A[i];
			for (j = i - 1; A[0] < A[j]; j--)
				A[j + 1] = A[j];
			A[j + 1] = A[0];
		}
	}
}
```

![](Images/2021-06-04-21-50-03.png)
![](Images/2021-06-04-21-50-38.png)

时间复杂度主要来自比对关键字、移动元素，若有n个元素，则需要n-1趟处理

### 优化

在向前查找插入位置的时候，因为前面的序列已经是有序的，所以可以使用二分查找来进行优化，

需要注意的是，这里的二分查找退出条件只有li<hi //保持算法的稳定性
![](Images/2021-06-04-21-52-03.png)

```c++
//时间复杂度 O(n^2)
//空间复杂度 O(1)
//稳定性： 稳定

void InsertSort(int A[], int n)
{
	int i, j;
	for (i = 1; i < n; i++)
	{
		if (A[i] < A[i - 1])
		{
			int temp = A[i];
			int li = 0, hi = i - 1;
			while (li <= hi)
			{
				int mi = (li + hi) / 2;
				if (A[mi] > temp)hi = mi - 1;
				else li = mi + 1;
			}
			for (j = i - 1; j >= li; j--)
				A[j + 1] = A[j];
			A[li] = temp;
		}
	}
}
```

## 希尔排序

算法思想：先追求表中元素部分有序，再逐渐逼近全局有序

![](Images/2021-06-04-22-36-24.png)

排序过程：先将待排序表分割成若⼲形如 $L[i, i + d, i + 2d,\cdots, i + kd]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量d，重复上述过程，直到d=1为⽌。

![](Images/2021-06-04-22-37-58.png)
![](Images/2021-06-04-22-38-12.png)
![](Images/2021-06-04-22-38-29.png)
![](Images/2021-06-04-22-38-53.png)
![](Images/2021-06-04-22-39-07.png)
![](Images/2021-06-04-22-39-19.png)
![](Images/2021-06-04-22-39-27.png)
![](Images/2021-06-04-22-39-39.png)
![](Images/2021-06-04-22-39-49.png)
![](Images/2021-06-04-22-39-57.png)

```c++
void ShellSort(int A[], int n)
{
	int d, i, j;
	for (d = n / 2; d >= 1; d /= 2)
	{
		for (i = d + 1; i <= n; i++)	//这里实现的是各个子表交替执行，见下图模拟
		{
			if (A[i] < A[i - d])
			{
				A[0] = A[i];
				for (j = i - d; j > 0 && A[0] < A[j]; j -= d)
					A[j + d] = A[j];
				A[j + d] = A[0];
			}
		}
	}
}
```
第一轮：
![第一轮](Images/2021-06-04-22-45-20.png)
第二轮：
![](Images/2021-06-04-22-45-47.png)

```c++
//另一种写法，每次都先将一个子表插入排序完毕之后再加工下一个子表

/* 解释：考虑到增量d会将整个序列分成d个子序列。比如数组{1,2,3,4,5,6,7,8}长度为8，增量为4
 * 此时子表分别为 {1,5}, {2,6}, {3,7}, {4,8}
 * 共有4个子表，而进行希尔排序的时候是从第一个子表的最后一个元素开始执行插入排序的
 * 例如第一个子表，我们会从元素5开始往前进行比较....
 * 
 * 知道了这个之后假设这样一个序列{20,30,10,50,60,40,70,80}
 * 假设现在的d为2,那么分成的子表就是{20,10,60,70}, {30,50,40,80}
 *
 * 第一轮循环k=0，i=d+0=d=2，也就是指向10这个元素，然后向前进行比较，符合交换的条件，
 * 子表变为{10,20,60,70}
 * 然后执行i+=d，在之前的代码中子表交错执行是i++，这里是i+=d，
 * 也就是i现在指向了60这个元素，然后向前比较，不符合交换条件...
 *
 * 第二轮循环k=1，i=d+1=3，也就是指向50这个元素...依此类推。
 */

void ShellSort(vector<int>& nums)
{
	for (int d = nums.size() / 2; d > 0; d /= 2)
	{
		for (int k = 0; k < d; k++)	//这里的k代表的就是进行到第k+1个子表
		{
			for (int i = d + k; i < nums.size(); i += d)
			{
				if (nums[i] < nums[i - d])
				{
					int j, temp = nums[i];
					for (j = i - d; j >= 0 && nums[j] > temp; j -= d)
						nums[j + d] = nums[j];
					nums[j + d] = temp;
				}
			}
		}
	}
}
```



### 性能分析

空间复杂度：O(1)

时间复杂度：和增量序列 d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度

最坏时间复杂度为 O(n^2^)，当n在某个范围内时，可达O(n^1.3^)

稳定性：不稳定

![](Images/2021-06-04-22-47-57.png)

仅适用于顺序表

## 冒泡排序

![](Images/2021-06-05-20-08-31.png)

```c++
//空间复杂度 O(1)
//时间复杂度：
//	最好：序列有序，O(n)
//	最坏：序列逆序，O(n^2)
//	平均：O(n^2)
//稳定性：稳定
//链表也可用

void BubbleSort(int A[], int len)
{
	//只需执行len-1趟，最小的len-1个元素放在合适的位置，最后一个元素自然就是最大的
	for (int i = 0; i < len - 1; i++)
	{
		bool flag = false;			//如果出现没有交换的情况，证明序列已经有序
		for (int j = len - 1; j > i; j--)
		{
			if (A[j - 1] > A[j])	//仅在严格大于时交换，保证算法稳定性
			{
				Swap(A[j - 1], A[j]);
				flag = true;
			}
		}
		if (!flag) return;
	}
}
```

## 快速排序

![](Images/2021-06-05-20-46-55.png)

思想：在待排序数组中取一段，把这段的第一个元素当作pivot值，然后想办法把这段中所有小于支点值的元素都挪到支点值的左边，把所有大于支点值的元素都挪到支点值的右边，这样，支点值就处在了它最终该在的位置----这一步成为”分区“(partition)。然后，把支点值以左的元素和支点值以右的元素各看作一段，继续(递归)进行分区操作，直到没有更小的段可以操作。这样，被选取的这段就排好序了。当然，如果选取的这段时整个序列，那么这个序列就排好序了。

```c++
//A数组中以low为起点，high为终点的序列，将low所指元素指定为基准，
//最终达到基准左边全部小于基准元素，基准右边全部大于基准元素，并返回基准元素所在位置
int Partition(int A[], int low, int high)	
{
	int pivot = A[low];
	while (low < high)
	{
		while (low < high && A[high] >= pivot)
			high--;
		A[low] = A[high];
		while (low < high && A[low] <= pivot)
			low++;
		A[high] = A[low];
	}
	A[low] = pivot;
	return low;
}

void QuickSort(int A[], int low, int high)
{
	if (low < high)
	{
		int pivotPos = Partition(A, low, high);
		QuickSort(A, low, pivotPos - 1);
		QuickSort(A, pivotPos + 1, high);
	}
}
```

## 选择排序

![](Images/2021-06-05-21-06-02.png)

每轮选择最小的元素，放在本轮的最前面。

```c++
//空间复杂度：O(1)
//时间复杂度：
//	最坏=最好=平均=O(n^2)
//稳定性：不稳定
void SelectSort(int A[], int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		int min = i;
		for (int j = i + 1; j < n; j++)
			if (A[j] < A[min]) min = j;
		if (min != i) Swap(A[i], A[min]);
	}
}
```

## 堆排序

![](Images/2021-06-05-22-20-04.png)

### 堆：

1. 忽略数组第一个元素(索引为0的元素)
2. 从索引为1的元素开始，把每个元素都看作是二叉树上的一个结点
3. 父子结点之间的关系：
    1. 当父结点的索引为i，左孩子为2i，右孩子为2i+1
    2. 当子结点索引为i，父结点索引为$\lfloor i/2\rfloor$
4. 可以把堆视作一棵“完全二叉树”(complete binary tree)，而数组则是这棵完全二叉树逐层(广度优先)访问所产生的串行化结果。
5. 当约束了父子结点之间的大小关系之后，就能得到两种很重要的堆
    1. 大根堆：任何一个父结点的值都比其子结点(如果有)的值大-----主要用于堆排序
    2. 小根堆：任何一个父结点的值都比其子结点(如果有)的值小-----主要应用于优先队列

### 大根堆和小根堆的性质：

1. 排好升/降序的数组是大/小根堆，但大/小根堆化的数组不一定是排好升/降序的。
2. 大根堆的值一定是数组的最大值，而且是数组索引为1的值
3. 小根堆的值一定是数组的最小值，而且是数组索引为1的值
4. 大/小根堆知识约束了父结点与子结点之间的大小关系，左右孩子之间的大小关系并不一定
5. 与二叉排序树没有任何关系

当构造了一个大顶堆之后，就能使用“选择排序”，选取第一个元素，放在最后面这种方式来对序列进行排序了。
![](Images/2021-06-05-21-57-43.png)

### 建立大/小根堆

1. 写一个算法，把大/小的元素从根向叶子“下沉”
2. 以从尾(最后一个分支结点)到头的顺序，把数组里的每个元素“下沉”一遍

如果下沉的是较小的元素，最终得到的就是一个大根堆，反之得到的就是小根堆。

```c++
/// <summary>
/// 将以k为根的子树调整为大根堆
/// </summary>
/// <param name="A">整个数组</param>
/// <param name="k">根结点所在位置</param>
/// <param name="len">以根结点为起始，待调整序列的长度</param>
void HeadAdjust(int A[], int k, int len)
{
	A[0] = A[k];							//A[0]暂存子树根结点
	for (int i = 2 * k; i <= len; i *= 2)	//i指向的是以k为根结点的左孩子
	{
		//比较左孩子与右孩子的值，如果右孩子大，让i指向右孩子
		if (i < len && A[i] < A[i + 1])
			i++;
		if (A[0] >= A[i]) break;			//如果根更大，跳出循环
		else
		{
			A[k] = A[i];					//将子结点中更大者放在根处
			//因为交换之后该子树可能不符合大根堆的定义，以被交换的位置为根继续调整
			k = i;
		}
	}
	A[k] = A[0];							//将最开始的根放在应该“下沉”的最终位置
}

void BuildMaxHeap(int A[], int len)
{
	for (int i = len / 2; i > 0; i--)	//从后往前调整所有的非终端结点
		HeadAdjust(A, i, len);
}
```

### 排序：

将数组堆化之后就可以进行排序了，首先将根结点元素(最大)与最后一个元素进行交换，

此时最大的元素排在了最后面，前面的n-1个元素可能不再符合大根堆的条件，将其根结点进行“下沉”，

于是数组的第一个元素(索引为1)就变成了前n-1个元素中的最大元素，将其与第n-1个元素进行交换...依此类推，n-1个较大的元素都已经放置在合适的位置之后就完成了排序。

```c++
void HeapSort(int A[], int len)
{
	BuildMaxHeap(A, len);			//将数组“堆化”
	for (int i = len; i > 1; i--)	//共进行n-1趟
	{
		Swap(A[i], A[1]);			//交换当前堆中第一个元素与最后一个元素
		HeadAdjust(A, 1, i - 1);	//调整当前堆去掉最后一个元素之后的堆
	}
}
```
### 效率分析：
![](Images/2021-06-05-22-18-42.png)
![](Images/2021-06-05-22-18-56.png)
![](Images/2021-06-05-22-19-09.png)
![](Images/2021-06-05-22-19-25.png)
![](Images/2021-06-05-22-19-37.png)

稳定性：不稳定，反例: {1,2,2}

### 堆的插入与删除：

![](Images/2021-06-05-22-31-22.png)

以小顶堆为例：

#### 插入：

新元素放到表尾，与⽗节点对⽐， 若==新元素==⽐==⽗节点==更⼩，则将⼆者互换。新元素 就这样⼀路==“上升”==，直到⽆法继续上升为⽌

#### 删除：

被删除的元素==⽤堆底元素替代==，然后让该 元素不断==“下坠”==，直到⽆法下坠为⽌

## 归并排序

![](Images/2021-06-06-19-42-42.png)

原理:

> 假设数组上从li到hi的一段上, li到mi已经是排好序的, mi+1 到 hi 也是排好序的(mi介于li和hi之间), 那么, 将li到mi与mi+1到hi两端归并到一起, 从li到hi这一整段就排好序了. 例如, 数组 {1,3,5,2,4,6,-1}, 把arr[0]到arr[5]视为一段, 不难发现a[0]到a[2]是排好序的{1,3,5}, a[3]到a[5]也是排好序的{2,4,6}, 如果将这两个子段归并到一起, 那么从a[0]到a[5]就也是排好序的, 整个数组就变成了{1,2,3,4,5,6,-1}.
>
> 需要注意的是, 在归并的时候,我们只关心段内的数据. 而且mi并不一定是一段数据的正中间, 只要由它分开的左右两段都是排好序的就可以了.

![](Images/2021-06-06-19-17-53.png)
![](Images/2021-06-06-19-18-05.png)
![](Images/2021-06-06-19-18-31.png)

2路归并: 将两个序列归并成一个, 每选出⼀个⼩元素注需对⽐关键字1次

n路归并: 将n个序列归并成一个,每选出⼀个⼩元素注需对⽐关键字n-1次

```c++
void Merge(int arr[], int aid[], int li, int mi, int hi)
{
	for (int i = li, p = li, q = mi + 1; i <= hi; i++)
	{
		if (p <= mi && q <= hi)		//两个子段都没有比对到最后一个
			aid[i] = arr[p] <= arr[q] ? arr[p++] : arr[q++];	//等号保证稳定
		else if (p > mi)			//左边的子段已经全部放入辅助数组
			aid[i] = arr[q++];
		else if (q > hi)			//右边的子段已经全部放入辅助数组 if 可省略
			aid[i] = arr[p++];
	}
	for (int i = li; i <= hi; i++)	//将辅助数组中的元素放回原数组
		arr[i] = aid[i];
}
```

```c++
void MergeSort(int arr[], int aid[], int li, int hi)
{
	if (li >= hi) return;
	int mi = (li + hi) / 2;			//分段
	MergeSort(arr, aid, li, mi);	//做半段
	MergeSort(arr, aid, mi + 1, hi);//右边
	Merge(arr, aid, li, mi, hi);	//左右归并
}
```
### 效率分析：

![](Images/2021-06-06-19-42-18.png)

## 基数排序

![](Images/2021-06-06-20-25-44.png)

不用比较的排序。可以当作一种思想。

### 例子

![](Images/2021-06-06-20-18-59.png)
![](Images/2021-06-06-20-19-22.png)

以Q9->Q1的顺序收集

![](Images/2021-06-06-20-19-35.png)
![](Images/2021-06-06-20-20-18.png)
![](Images/2021-06-06-20-20-27.png)
![](Images/2021-06-06-20-20-44.png)
![](Images/2021-06-06-20-20-56.png)
![](Images/2021-06-06-20-21-02.png)
![](Images/2021-06-06-20-21-15.png)
![](Images/2021-06-06-20-21-24.png)
![](Images/2021-06-06-20-21-33.png)
![](Images/2021-06-06-20-21-51.png)
![](Images/2021-06-06-20-21-57.png)
![](Images/2021-06-06-20-22-11.png)
![](Images/2021-06-06-20-22-26.png)

### 文字描述

![](Images/2021-06-06-20-23-07.png)

### 效率分析

![](Images/2021-06-06-20-23-35.png)

这里的队列采用链式存储，故一趟收集只需要遍历所有队列，将队头元素指针置于序列尾即可

稳定性：稳定

### 应用

![](Images/2021-06-06-20-25-03.png)

![](Images/2021-06-06-20-25-30.png)

## 外部排序

1. 磁盘的读/写以“块”为单位，数据读⼊内存后才能被修改，修改完了还要写回磁盘
2. 操作系统以“块”为单位对磁盘存储空间进⾏管理，如：每块⼤⼩ 1KB  各个磁盘块内存放着各种各样的数据
3. 使⽤“归并排序”的⽅法，最少只需在内存 中分配3块⼤⼩的缓冲区即可对任意⼀个⼤⽂件进⾏排序
	![](Images/2021-06-06-20-50-19.png)
![](Images/2021-06-06-20-50-56.png)
![](Images/2021-06-06-20-51-26.png)

本质还是归并排序，只是整个的序列不是依次遍历完毕，在遍历完一个输入缓冲区之后需要将外存中的数据先读进内存然后再继续进行归并

![](Images/2021-06-06-20-51-53.png)
![](Images/2021-06-06-20-52-54.png)
![](Images/2021-06-06-20-53-09.png)
![](Images/2021-06-06-20-53-24.png)
![](Images/2021-06-06-20-53-48.png)
![](Images/2021-06-06-20-54-03.png)

### 优化
![](Images/2021-06-06-20-54-21.png)
![](Images/2021-06-06-20-54-38.png)
![](Images/2021-06-06-20-54-52.png)
![](Images/2021-06-06-20-55-13.png)
![](Images/2021-06-06-20-55-25.png)
![](Images/2021-06-06-20-55-35.png)
![](Images/2021-06-06-20-55-46.png)
![](Images/2021-06-06-20-55-57.png)

K路平衡归并：

![](Images/2021-06-06-20-56-34.png)
![](Images/2021-06-06-20-56-50.png)

 ### 败者树

引出：多路平衡归并带来的问题是内部归并所需要的时间增加了。例如8路平衡归并，从8个归并段中选出一个最小元素需要比对关键字7次。可以使用败者树进行优化

![](Images/2021-06-06-21-16-10.png)
![](Images/2021-06-06-21-16-26.png)
![](Images/2021-06-06-21-16-45.png)

> 败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。k个叶结点分别是当前参加⽐较的元素，⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”，⽽让胜者往上继续进⾏⽐较，⼀直到根结点。
> ![](Images/2021-06-06-21-17-26.png)
>
> 当构造完了败者树之后，优胜者就是所需要的n个归并段中最小的元素，此时将优胜者取出，然后从优胜者所属的归并段中下一个元素替代最开始的位置
> ![](Images/2021-06-06-21-19-06.png)
>
> 此时派大星只需要比较阿乐与程龙还有孙悟空即可，这样仍然可以选出一个优胜者，依此循环
> 也就是构造完败者树之后每一次选取优胜者只需要比对树的高度次就可以了。
> 
> 对于 k 路归并，第⼀次构造败者树需要对⽐关键字 k-1 次
> 有了败者树，选出最⼩元素，只需对⽐关键字⌈log~2~k⌉次

![](Images/2021-06-06-21-21-54.png)
![](Images/2021-06-06-21-22-04.png)
![](Images/2021-06-06-21-22-13.png)

### 置换-选择排序
![](Images/2021-06-06-21-52-35.png)

### 最优归并树

文件通过置换-选择排序之后，得到的是长度不等的初始归并段。怎样的归并策略能使得I/O次数最少呢？

#### 二路归并

随便搞：

![](Images/2021-06-06-21-54-10.png)

哈夫曼树：

![](Images/2021-06-06-21-54-18.png)

#### 多路归并

随意搞：

![](Images/2021-06-06-21-54-26.png)

多叉哈夫曼：
![](Images/2021-06-06-21-55-24.png)

#### 注意事项

![](Images/2021-06-06-21-55-54.png)
![](Images/2021-06-06-21-56-05.png)
![](Images/2021-06-06-21-56-11.png)
![](Images/2021-06-06-21-56-31.png)
![](Images/2021-06-06-21-56-40.png)
![](Images/2021-06-06-21-56-48.png)