# 图

## 概念

![](Images/2021-05-26-21-19-57.png)

### 图的定义

图G由**顶点集V**和**边集E**组成,记作 G=(V, E); V(G)代表图G中顶点的==有限非空集==；E(G)表示图G中顶点之间的关系(边)集合。若V={v~1~, v~2~, $\cdots$, v~n~}，则用|V|表示图G中顶点的个数，也称作图G的阶; E = {(u, v)| u∈V，v∈V}，用|E|表示图G中边的条数。

注：线性表、树可以为空，但图不可以为空，V一定是非空集

### 分类

#### 有向、无向

若E是无向边（简称$）的有限集合时，则图G为无向图。边 是顶点的无序对，记为(v, w)或(w, v)，因为(v, w) = (w, v)，其 中v、w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w) 依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。

![](Images/2021-05-26-20-22-08.png)

若E是有向边（也称弧）的有限集合时，则图G为有向图。 弧是顶点的有序对，记为<v, w>，其中v、w是顶点，v称为弧尾，w称为弧头，<v, w>称为从顶点v到顶点w的弧，也称 v邻接到w，或w邻接自v。  ==<v, w> ≠ <w, v>==

![](Images/2021-05-26-20-22-27.png)

#### 简单、多重

简单图——① 不存在重复边； ② 不存在顶点到自身的边

多重图——图G中某两个结点之间的边数多于 一条，又允许顶点通过同一条边和自己关联， 则G为多重图

![](Images/2021-05-26-20-23-42.png)

#### 连通图、强连通图

1. 连通图

    若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图

    > **常见考点：**
    >
    > 对于n个顶点的无向图G
    >
    > 若G是连通图，则最少有n-1条边
    >
    > 若G是非连通图，则最多可能有$C_{n-1}^2$条边

    ![](Images/2021-05-26-20-57-21.png)

2. 强连通图

    若图中任何一对顶点都是强连通的，则称此图为强连通图。

    > **常见考点：**
    >
    > 对于n个顶点的有向图G，
    >
    > 若G是强连通图，则最少有 n 条边（形成回路）
    
    ![](Images/2021-05-26-20-58-39.png)

#### 特殊形态的图

1. 无向完全图——无向图中任意两个顶点之间都存在边

    > 若无向图的顶点数|V| = n，则|E| ∈ [0, $C_n^2$] = [0, $\frac{n(n-1)}{2}$]

    ![](Images/2021-05-26-21-15-36.png)

2. 有向完全图——有向图中任意两个顶点 之间都存在方向相反的两条弧

    > 若有向图的顶点数|V| = n，则|E| ∈ [0, $2C_n^2$] = [0, $n(n-1)$]

3. 稀疏图：边数很少的图称为稀疏图

4. 反之为稠密图

    没有绝对的界限，一般来说|E| < |V|log|V|时，可以将G视为稀疏图

5. 树：不存在回路，且连通的无向图

    ![](Images/2021-05-26-21-18-39.png)

    n个顶点的树，必有n-1条边。

    > 常见考点：n个顶点的图，若 |E|>n-1，则一定有回路

6. 有向树：一个顶点的入度为0、其余顶点的 入度均为1的有向图，称为有向树。

    ![](Images/2021-05-26-21-19-09.png)

### 度

对于==无向图==：顶点v的度是指依附于该顶点的边的条数，记为TD(v)。
$\sum_{i=1}^{n}TD(v_i)=2|E|$    即无向图的全部顶点的度的和等于边数的2倍

对于==有向图==：

1. 入度是以顶点v为终点的有向边的数目，记为ID(v)；
2.  出度是以顶点v为起点的有向边的数目，记为OD(v)。
3.  顶点v的度等于其入度和出度之和，即TD(v) = ID(v) + OD(v)

在具有n个顶点、e条边的有向图中 $\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)=e$

### 边关系描述

1. 路径：顶点v~p~到顶点v~q~之间的一条路径是指顶点序列 ，v~p~, v~i1~, v~i2~, $\cdots$, v~im~, v~q~
2. 回路：第一个顶点和最后一个顶点相同的路径称为回路或环
3. 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。
4. 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。
5. 路径长度：路径上边的数目
6. 点到点的距离：从顶点u出发到顶点v的==最短路径==若存在，则==此路径的长度称为从u到v的距离。==若从u到v根本不存在路径，则记该距离为无穷($\infty$)
7. ==无向图==中，若从顶点v到顶点w有路径存在，则称v和w是==连通==的
8. ==有向图==中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是==强连通==的
9. 边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。
10. 带权图/网：边上带有权值的图称为带权图，也称网。
11. 带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度

### 子图

设有两个图G = (V, E)和G' = (V' , E' )，若V' 是V的子集，且E' 是 E的子集，则称G' 是G的子图。

若有满足V(G' ) = V(G)的子图G' ，则称其为G的生成子图	//顶点一样，去掉几个边

并非任意挑几个点、几条边都能构成子图：可能挑出来的就不是个图 (边没有连点)

上述概念对于有向图和无向图都是一样的

![](Images/2021-05-26-21-00-47.png)

### 连通分量、强连通分量

无向图中的==极大连通子图==称为==连通分量==。 //子图必须连通，且包含尽可能多的顶点和边

![](Images/2021-05-26-21-04-17.png)

例如：中国铁路网有3个连通分量：大陆铁路网，台湾铁路网、海南铁路网

有向图中的==极大强连通子图==称为有向图的==强连通分量== //子图必须强连通，同时保留尽可能多的边

![](Images/2021-05-26-21-06-27.png)

### 生成树、生成森林

==连通图==的生成树是==包含图中全部顶点的一个极小连通子图==	//边要尽可能少，但是要保持连通

若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通 图，若加上一条边则会形成一个回路。
![](Images/2021-05-26-21-07-58.png)

> 区分极大连通子图和极小连通子图。极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图

在==非连通图==中，==连通分量的生成树==构成了非连通图的==生成森林==。

![](Images/2021-05-26-21-10-47.png)

## 图的存储以及基本操作

### 邻接矩阵法

用一个一维数组存储图中顶点信息，用一个二维数组存储图中边的信息(即各个顶点之间的邻接关系)，存储顶点之间的邻接关系的二维数组称为`邻接矩阵`

#### 存储不带权的图

```c++
#define MaxVertexNum 100
typedef struct
{
	char Vex[MaxVertexNum];
	int Edge[MaxVertexNum][MaxVertexNum];
	int vexNum, arcNum;
}MGraph;
```

![](Images/2021-05-26-22-00-05.png)

#### 求度

在无向图中：对应结点的行/列求和，就是度

在有向图中：对应结点行和为出度，列和为入度。度为行和、列和相加

时间复杂度为O(|V|)

#### 存储带权图

```c++
#define MaxVertexNum 100
#define INFINITY INT_MAX
typedef char VertexType;
typedef int EdgeType;
typedef struct
{
	VertexType Vex[MaxVertexNum];
	EdgeType Edge[MaxVertexNum][MaxVertexNum];
	int vexNum, arcNum;
}MGraph;
```

当两个顶点之间有边时，邻接矩阵对应元素值为权值，否则为INFINITY

> 注：主对角线元素可以是无穷也可以是0

#### 性能分析

空间复杂度：O( |V|^2^ ) ——只和顶点数相关，和实际的边数无关

适合用于存储稠密图

无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）

#### 性质

设图G的邻接矩阵为A（矩阵元素为0/1），则A^n^ 的元素A^n^[i][j]等于由顶点i到顶点j的长度为n的路径的数目

![](Images/2021-05-26-22-09-09.png)

例如上图

$\begin{pmatrix}
0&1&0&0 \\
1&0&1&1 \\
0&1&0&1 \\
0&1&1&0 \\
\end{pmatrix} * 
\begin{pmatrix}
0&1&0&0 \\
1&0&1&1 \\
0&1&0&1 \\
0&1&1&0 \\
\end{pmatrix} => A^2[1][4] =  a_{1,1} a_{1,4} + a_{1,2} a_{2,4} + a_{1,3} a_{3,4} + a_{1,4} a_{4,4} = 1$

其中$a_{1,2}a_{2,4} = 1 * 1 = 1$代表的意思是从A到B有一条边，从B到D有一条边，故从A到D的距离为2的边有一条是A->B->D；如果其中有一条边为0，那么乘积的结果就是0，也就是没有边；

同理可以推算到$A^n[i][j]$就代表从i结点到j结点长度为n的路径的数目

### 邻接表法

#### 结点定义

```c++
typedef struct ArcNode	//边
{
	int adjVex;			//边指向哪个结点
	struct ArcNode* next;	//指向下一条弧的指针
}ArcNode;

typedef struct VNode	//顶点
{
	VertexType data;	
	ArcNode* first;		//第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct			//用邻接表存储的图
{
	AdjList vertices;
	int vexNum, arcNum;
}ALGraph;
```

![](Images/2021-05-27-19-19-13.png)

> 表格中存的是顶点，而链表中的是与顶点相连的边。

#### 性能分析

> 对于无向图而言
>
> 1. 边结点的数量是2|E|， 整体空间复杂度为 O(|V| + 2|E|)
> 2. 求度将对应结点的链表遍历计数即可
>
> 
>
> 对于有向图而言
>
> 1. 边结点的数量是|E|， 整体空间复杂度为 O(|V| + |E|)
> 2. 出度遍历对应结点的链表即可，入度需遍历整个表

#### 与邻接矩阵对比

![](Images/2021-05-27-19-29-14.png)

### 十字链表法和邻接多重表

#### 十字链表法(适用于有向图)

引出：对于有向图而言，如果用邻接表来存储，查顶点的入度不方便；而如果使用邻接矩阵来存储的话空间复杂度又太高，因此就有了十字链表法这种存储方法

```c++
typedef int Weight;

typedef struct CArcNode	//十字链表法弧结点定义
{
	int tailVex;	//弧尾顶点编号
	int headVex;	//弧头顶点编号
	// Weight weight;	//权值
	struct CArcNode* hLink;	//弧头相同的下一条弧
	struct CArcNode* tLink;	//弧尾相同的下一条弧
}CArcNode;

typedef struct CVNode	//十字链表法顶点结点定义
{
	VertexType data;
	CArcNode* firstIn;	//该顶点作为弧头的第一条弧
	CArcNode* firstOut;	//该顶点作为弧尾的第一条弧
}CVNode, CrossList[MaxVertexNum];

typedef struct
{
	CrossList vertices;
	int vexNum, arcNum;
}CrossGraph;
```
![](Images/2021-05-27-19-47-15.png)

> 从一个顶点开始，找所有出边，就是按着绿色的指针一直找。

#### 一些性质

1. 空间复杂度：O(|V|+|E|)
2. 如何找到指定顶点的所有出边？——顺着绿色线路找 
3. 如何找到指定顶点的所有入边？——顺着橙色线路找

#### 邻接多重表(适用于无向图)

引出：对于无向图而言，如果使用邻接表来存储，会导致每条边对应两份冗余信息， 删除顶点、删除边等操作 时间复杂度高；如果使用邻接矩阵来存储，空间复杂度太高。

![](Images/2021-05-27-19-52-52.png)

#### 一些性质

1. 空间复杂度：O(|V|+|E|) //每条边对应一份数据
2. 删除边、删除节点等操作很方便

### 总结

![](Images/2021-05-27-19-54-50.png)

## 遍历

### 需要准备的接口

1. FirstNeighbor(G,x)

    求图G中顶点x的第⼀个邻接点，若有则返回顶点号。 若x没有邻接点或图中不存在x，则返回-1。

2. NextNeighbor(G,x,y)

    假设图G中顶点y是顶点x的⼀个邻接点，返回除y之外 顶点x的下⼀个邻接点的顶点号，若y是x的最后⼀个邻接点，则返回-1

### BFS

#### 要点

1. 找到与⼀个顶点相邻的所有顶点 
2. 标记哪些顶点被访问过
3. 需要⼀个辅助队列

#### 代码

```c++
void BFS(Graph G, int v)
{
	queue<int> q;	//辅助队列
	VisitGraphNode(v);	//访问结点
	visited[v] = true;	//标记已经访问过
	q.push(v);			
	while (!q.empty())
	{
		v = q.front();
		q.pop();
       	//找到与结点相连的所有结点，访问并入队
		for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
		{
			if (!visited[w])
			{
				VisitGraphNode(w);
				visited[w] = true;
				q.push(w);
			}
		}
	}
}
```

>  【注】
>
> ​	同⼀个图的邻接矩阵表示⽅式唯⼀，因此⼴度优先遍历序列唯⼀
>
> ​	同⼀个图邻接表表示⽅式不唯⼀，因此⼴度优先遍历序列不唯⼀

#### 完整代码

如果图是非连通图，那么依次BFS不能够完整地遍历整个图，需要增加逻辑

![](Images/2021-05-27-21-18-42.png)

```c++
bool visited[MaxVertexNum];

void BFS(Graph G, int v)
{
	queue<int> q;	//辅助队列
	VisitGraphNode(v);	//访问结点
	visited[v] = true;	//标记已经访问过
	q.push(v);
	while (!q.empty())
	{
		v = q.front();
		q.pop();
        //找到与结点相连的所有结点，访问并入队
		for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
		{
			if (!visited[w])
			{
				VisitGraphNode(w);
				visited[w] = true;
				q.push(w);
			}
		}
	}
}

void BFSTraverse(Graph G)
{
	for (int i = 0; i < G.vexNum; i++)
		visited[i] = false;
	for (int i = 0; i < G.vexNum; i++)
	{
        //如果一次BFS没有把图中所有的结点遍历完，则从第一个没有访问过的结点再来一次BFS，直到访问完整个图
		if (!visited[i])	
			BFS(G, i);
	}
}
```

> 结论：对于无向图而言，==调用BFS函数的次数等于连通分量数==

#### 复杂度分析

##### 空间复杂度

最坏情况，辅助队列⼤⼩为 O(|V|)

![](Images/2021-05-27-21-24-51.png)

##### 时间复杂度

1. 邻接矩阵存储的图

    访问 |V| 个顶点需要O(|V|)的时间

    查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点

    时间复杂度= O(|V|2)

2. 邻接表存储的图

    访问 |V| 个顶点需要O(|V|)的时间

    查找各个顶点的邻接点共需要O(|E|)的时间，	//对于无向图而言其实是 2|E|

    时间复杂度= O(|V|+|E|)

#### 广度优先生成树

在遍历过程中，通过当前结点压入队列的所有结点当作当前结点的孩子，就得到了树(无环)

对于下图而言，从2开始进行广搜的生成树就是右边的结果

![](Images/2021-05-27-21-29-36.png)

> ⼴度优先⽣成树由⼴度优先 遍历过程确定。由于邻接表 的表示⽅式不唯⼀，因此基 于邻接表的⼴度优先⽣成树 也不唯⼀。

#### 广度优先生成森林

对⾮连通图的⼴度优先遍历，可得到⼴度优先⽣成森林

![](Images/2021-05-27-21-31-17.png)

#### 总结

![](Images/2021-05-27-21-32-00.png)

### DFS

#### 代码

```c++
bool visited[MaxVertexNum];

void DFS(Graph G, int v)
{
	VisitGraphNode(v);
	visited[v] = true;
	for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
	{
		if (!visited[w])	//优先往深处探索
			DFS(G, w);
	}
}
```

> 【注】
>
> 同⼀个图的邻接矩阵表示⽅式唯⼀，因此深度优先遍历序列唯⼀，深度优先⽣成树也唯⼀
>
> 同⼀个图邻接表表示⽅式不唯⼀，因此深度优先遍历序列不唯⼀，深度优先⽣成树也不唯⼀

#### 完整代码

同样存在与BFS同样的问题，如果图是非连通图，则一次DFS无法访问整个图，处理方法也类似

```c++
bool visited[MaxVertexNum];

void DFS(Graph G, int v)
{
	VisitGraphNode(v);
	visited[v] = true;
	for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
	{
		if (!visited[w])	//优先往深处探索
			DFS(G, w);
	}
}

void DFSTraverse(Graph G)
{
	for (int i = 0; i < G.vexNum; i++)
		visited[i] = false;
	for (int i = 0; i < G.vexNum; i++)
		if (!visited[i])
			DFS(G, i);
}
```

#### 复杂度分析

##### 空间复杂度

主要来自递归调用栈

![](Images/2021-05-27-21-41-08.png)

##### 时间复杂度

1. 邻接矩阵存储

    访问 |V| 个顶点需要O(|V|)的时间

    查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点

    时间复杂度= ==O(|V|2)==

2. 邻接表存储的图：

    访问 |V| 个顶点需要O(|V|)的时间

    查找各个顶点的邻接点共需要O(|E|)的时间

    时间复杂度= O(|V|+|E|)

#### 深度优先生成树

在遍历过程中，通过当前结点访问到的结点成为当前结点的孩子，也就成了树(无环)

#### 深度优先生成森林

对于非连通图而言，每一个连通分量的生成树共同组成了生成森林

### 总结

![](Images/2021-05-27-21-46-49.png)