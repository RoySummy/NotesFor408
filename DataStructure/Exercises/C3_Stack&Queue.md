# 栈与队列

## 0. 总结

## 1. 选择题

### 1.1 

> 设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是( C )
>
> A. 只有表头结点指针，没有表尾指针的双向循环链表
>
> B. 只有表尾结点指针，没有表头指针的双向循环链表
>
> C. 只有表头结点指针，没有表尾指针的单向循环链表
>
> D. 只有表尾结点指针，没有表头指针的单向循环链表
>
> > 解析：对于双向循环链表，不管是表头指针还是表尾指针，都可以方便地找到表头结点，方便在头部做插入删除操作。而单循环链表通过尾指针可以方便的找到表头，而且很方便删除，但是通过表头指针找到尾指针从而删除头指针是比较烦琐的，需要O(n)，错选了D，没仔细看题目。

### 1.2

> 一个栈的入栈序列为 1, 2, 3, ..., n，出栈序列是 P1, P2, P3, ..., Pn. 若P2 = 3，则P3可能取值的个数为( C )
>
> A. n - 3     B. n - 2     C. n - 1     D. 无法确定
>
> > 解析：显然，3之后的4到n都是可以取的数。接下来分析1和2，P1可以是3之前入栈的数( 1和2 )，也可以是4，当P1为1时，P3可以取2，当P1为2时，P3可以取1，当P1为4时，P3可以取除了1, 3, 4 之外的所有数。故P3可能的取值个数为 n-1

## 2. 判断序列是否中心对称

假设单链表的表头指针为L，结点结构为 [data, next]，其中data域为字符型，设计算法判断该链表的全部n个字符是否中心对称。例如xyx，xyyx都是中心对称。

> [分析] 拿到这道题的疑惑点：表头指针是否代表有头结点。如果带头结点的话我的思路就可以用。看了答案之后是带头结点的。
>
> 我的思路：快慢指针，找到中间节点`(见C2线性表笔记中总结的使用快慢指针查找中间节点有何不同)`，然后将后半部分逆置，slow最终指向Round(n/2)，然后再从第一个元素开始与后半部分进行比较。时间复杂度，找到中间节点 O(n/2) 逆置O(n/2)，比较O(n/2)
>
> 答案思路：题目给出了元素的个数n，因此用一个数组和一个下标变量模拟栈，将前n/2个字符放入模拟的栈中，然后继续遍历链表，与每次弹栈的元素进行比较。当元素个数为奇数的时候需要先将指针后移一位，再与弹栈的元素相比。

```c++
bool SymmetryString(LinkList L, int n)
{
	int i;
  //这里使用new是因为 char s[n/2]的语法在vs中过不去，但是答案上是这样写的，感觉用vector也可以。
  //考试的话自己应该会用vector
	char* s = new char[n / 2];		
	Node* p = L->next;
	for (i = 0; i < n / 2; i++)
	{
		s[i] = p->data;
		p = p->next;
	}
	i--;								//让i指向栈顶元素
	if (n % 2 == 1)		//元素个数为奇数
		p = p->next;
	while (p != NULL && s[i] == p->data)
	{
		i--;
		p = p->next;
	}
	return i == -1;
}
```

