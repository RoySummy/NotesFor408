# 进程管理

[TOC]

## 进程的概念、组成、特征

![image-20210727203310928](Images/image-20210727203310928.png)

### 概念

程序：==静态的==，就是放在磁盘里的可执行文件，例如QQ.exe

进程：==动态的==，是程序(进程实体)的一次执行过程

同一个程序多次执行会对应不同的进程

### 组成

![image-20210727203623129](Images/image-20210727203623129.png)

![image-20210727203741714](Images/image-20210727203741714.png)

### 特征

![image-20210727203806756](Images/image-20210727203806756.png)

## 进程的状态与转换、进程的组织

![image-20210727205736640](Images/image-20210727205736640.png)

![image-20210727210058617](Images/image-20210727210058617.png)

### 状态

![image-20210727205959563](Images/image-20210727205959563.png)

### 转换/丁字裤模型

![image-20210727205926308](Images/image-20210727205926308.png)

### 组织方式

![image-20210727210023617](Images/image-20210727210023617.png)

![image-20210727210039038](Images/image-20210727210039038.png)

## 进程控制

![image-20210727212555858](Images/image-20210727212555858.png)

### 基本概念

进程控制就是要实现进程状态转换

> 为什么进程控制要用原语来实现：
>
> ![image-20210727212724429](Images/image-20210727212724429.png)

### 相关原语

1. 更新PCB中的信息 

   ​	a. 所有的进程控制原语一定都会修改进程状态标志 

   ​	b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境 

   ​	c. 某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列

3. 分配/回收资源

#### 创建

![image-20210727212815868](Images/image-20210727212815868.png)

#### 终止

![image-20210727212833100](Images/image-20210727212833100.png)

#### 阻塞、唤醒

![image-20210727212853260](Images/image-20210727212853260.png)

#### 切换

![image-20210727212930008](Images/image-20210727212930008.png)

#### 总览

![image-20210727213146915](Images/image-20210727213146915.png)

## 进程通信

![image-20210727215831262](Images/image-20210727215831262.png)

> 为什么进程通信需要操作系统支持：
>
> 为了保证安全，一个进程不能直接访问另 一个进程的地址空间

### 共享存储

为了避免出错，各个进程对共享空间的==访问==是==互斥==的

![image-20210727215959491](Images/image-20210727215959491.png)

### 消息传递

![image-20210727220112174](Images/image-20210727220112174.png)

#### 直接通信

![image-20210727220144519](Images/image-20210727220144519.png)

#### 间接通信

![image-20210727220216219](Images/image-20210727220216219.png)

### 管道通信

![image-20210727220232998](Images/image-20210727220232998.png)

> 写进程往管道写数据，即便管道没被写满，==只要管道没空，读进程就可以从管道读数据==
>
> 读进程从管道读数据，即便管道没被读空，==只要管道没满，写进程就可以往管道写数据==

## 线程的概念与特点

### 为什么要引入线程

![image-20210727221143006](Images/image-20210727221143006.png)

![image-20210727221204314](Images/image-20210727221204314.png)

### 引入线程带来的变化

![image-20210727221229547](Images/image-20210727221229547.png)

### 线程的属性

![image-20210727221247318](Images/image-20210727221247318.png)

### 线程的实现方式

![image-20210727222553202](Images/image-20210727222553202.png)

#### 用户级线程

![image-20210727222624922](Images/image-20210727222624922.png)

#### 内核级线程

![image-20210727222658866](Images/image-20210727222658866.png)

### 多线程模型

#### 一对一

![image-20210727222726849](Images/image-20210727222726849.png)

#### 多对一

![image-20210727222757077](Images/image-20210727222757077.png)

#### 多对多

![image-20210727222819297](Images/image-20210727222819297.png)

## 调度的概念

![image-20210730180413074](Images/image-20210730180413074.png)

> 简单理解：
>
> 高级调度：进程创建/销毁
>
> 中级调度：进程放到外存，放回内存
>
> 低级调度：进程分配处理机

![image-20210730180427063](Images/image-20210730180427063.png)

![image-20210730180440804](Images/image-20210730180440804.png)

## 进程调度

![image-20210730181704563](Images/image-20210730181704563.png)

### 进程调度的时机

![image-20210730181759331](Images/image-20210730181759331.png)

![image-20210730181741226](Images/image-20210730181741226.png)

### 进程调度的方式

![image-20210730181837722](Images/image-20210730181837722.png)

### 进程的切换与过程

![image-20210730181902659](Images/image-20210730181902659.png)

## 调度算法的评价指标

![image-20210731183411069](Images/image-20210731183411069.png)

> 所有周转时间都是越小越好

## 调度算法

![image-20210731190031893](Images/image-20210731190031893.png)

![image-20210731203620625](Images/image-20210731203620625.png)

### 先来先服务

![image-20210731190111709](Images/image-20210731190111709.png)

![image-20210731190140254](Images/image-20210731190140254.png)

### 短作业优先

![image-20210731190214469](Images/image-20210731190214469.png)

#### 抢占式

![image-20210731190238625](Images/image-20210731190238625.png)



#### 非抢占式

![image-20210731190438234](Images/image-20210731190438234.png)

![image-20210731190355567](Images/image-20210731190355567.png)

#### 注意

![image-20210731190504216](Images/image-20210731190504216.png)

### 高响应比优先

==FCFS 算法==是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对==短作业不友好==的问题

==SJF 算法==是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因 此导致了对==长作业不友好==的问题，甚至还会造成==饥饿问题==

高响应比优先既考虑到各个作业的等待时间，也兼顾运行时间



![image-20210731190559641](Images/image-20210731190559641.png)

![image-20210731190618658](Images/image-20210731190618658.png)

### 时间片轮转

![image-20210731203149241](Images/image-20210731203149241.png)

#### 时间片小

![image-20210731203216627](Images/image-20210731203216627.png)

![image-20210731203237897](Images/image-20210731203237897.png)

![image-20210731203255380](Images/image-20210731203255380.png)

#### 时间片大

![image-20210731203058399](Images/image-20210731203058399.png)

### 优先级调度

![image-20210731203331622](Images/image-20210731203331622.png)

![image-20210731203408641](Images/image-20210731203408641.png)

#### 非抢占式

![image-20210731203426971](Images/image-20210731203426971.png)

#### 抢占式

![image-20210731203458427](Images/image-20210731203458427.png)

### 多级反馈队列调度

![image-20210731203530195](Images/image-20210731203530195.png)

![image-20210731203556927](Images/image-20210731203556927.png)

## 进程同步、互斥

![image-20210731205508103](Images/image-20210731205508103.png)

### 同步

![image-20210731205526222](Images/image-20210731205526222.png)

### 互斥

![image-20210731205555524](Images/image-20210731205555524.png)

![image-20210731205611062](Images/image-20210731205611062.png)

![image-20210731205622454](Images/image-20210731205622454.png)

## 进程互斥的软件实现

![image-20210803200644011](Images/image-20210803200644011.png)

### 单标志法

![image-20210803200719442](Images/image-20210803200719442.png)

![image-20210803200809207](Images/image-20210803200809207.png)

### 双标志法

#### 先检查

![image-20210803200848596](Images/image-20210803200848596.png)

![image-20210803200915714](Images/image-20210803200915714.png)

#### 后检查

![image-20210803201009960](Images/image-20210803201009960.png)

![image-20210803200950969](Images/image-20210803200950969.png)

### Peterson算法

![image-20210803201034127](Images/image-20210803201034127.png)

![image-20210803201056490](Images/image-20210803201056490.png)

## 进程互斥的硬件实现

![image-20210803202554500](Images/image-20210803202554500.png)

### 中断屏蔽方法

![image-20210803202615663](Images/image-20210803202615663.png)

### TS/TSL指令

![image-20210803202639954](Images/image-20210803202639954.png)

### Swap指令

![image-20210803202659713](Images/image-20210803202659713.png)

## 信号量机制

![image-20210803221402633](Images/image-20210803221402633.png)

![image-20210803221348409](Images/image-20210803221348409.png)

![image-20210803221418142](Images/image-20210803221418142.png)

![image-20210803221432355](Images/image-20210803221432355.png)

![image-20210803221449743](Images/image-20210803221449743.png)

![image-20210803221502502](Images/image-20210803221502502.png)

## 信号量机制实现进程同步、互斥

![image-20210804111046875](Images/image-20210804111046875.png)

### 互斥

![image-20210804111110359](Images/image-20210804111110359.png)

### 同步

![image-20210804111143850](Images/image-20210804111143850.png)

![image-20210804111159640](Images/image-20210804111159640.png)

## 生产者-消费者问题

![image-20210804112511053](Images/image-20210804112511053.png)

![image-20210804112531519](Images/image-20210804112531519.png)

![image-20210804112547994](Images/image-20210804112547994.png)

```c++
semaphore mutex = 1;		//互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;		//同步信号量，表示空闲缓冲区的数量
semaphore full = 0;			//同步信号量，表示产品的数量，也即非缓冲区的数量
```

![image-20210804112752774](Images/image-20210804112752774.png)

![image-20210804112810171](Images/image-20210804112810171.png)

## 多生产者-多消费者

![image-20210804114308754](Images/image-20210804114308754.png)

![image-20210804114401054](Images/image-20210804114401054.png)

![image-20210804114422219](Images/image-20210804114422219.png)

![image-20210804114434804](Images/image-20210804114434804.png)

![image-20210804114449078](Images/image-20210804114449078.png)

![image-20210804114503003](Images/image-20210804114503003.png)

## 吸烟者问题

![image-20210804115332963](Images/image-20210804115332963.png)

![image-20210804115416375](Images/image-20210804115416375.png)

![image-20210804115356529](Images/image-20210804115356529.png)

![image-20210804115451240](Images/image-20210804115451240.png)

![image-20210804115510370](Images/image-20210804115510370.png)

## 读者-写者问题

![image-20210804125628410](Images/image-20210804125628410.png)

![image-20210804125719267](Images/image-20210804125719267.png)

![image-20210804125647740](Images/image-20210804125647740.png)

![image-20210804125735557](Images/image-20210804125735557.png)

![image-20210804125750366](Images/image-20210804125750366.png)

## 哲学家进餐问题

![image-20210804131214813](Images/image-20210804131214813.png)

![image-20210804131235935](Images/image-20210804131235935.png)

![image-20210804131254413](Images/image-20210804131254413.png)

> 如何防止死锁的发生？
>
> 1. 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的
> 2. 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证 如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就 避免了占有一支后再等待另一只的情况
> 3. 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子

![image-20210804131441868](Images/image-20210804131441868.png)

## 管程

![image-20210804135241168](Images/image-20210804135241168.png)

![image-20210804135259674](Images/image-20210804135259674.png)

![image-20210804135315271](Images/image-20210804135315271.png)

![image-20210804135329278](Images/image-20210804135329278.png)