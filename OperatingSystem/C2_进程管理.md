# 进程管理

[TOC]

## 进程的概念、组成、特征

![image-20210727203310928](Images/image-20210727203310928.png)

### 概念

程序：==静态的==，就是放在磁盘里的可执行文件，例如QQ.exe

进程：==动态的==，是程序(进程实体)的一次执行过程

同一个程序多次执行会对应不同的进程

### 组成

![image-20210727203623129](Images/image-20210727203623129.png)

![image-20210727203741714](Images/image-20210727203741714.png)

### 特征

![image-20210727203806756](Images/image-20210727203806756.png)

## 进程的状态与转换、进程的组织

![image-20210727205736640](Images/image-20210727205736640.png)

![image-20210727210058617](Images/image-20210727210058617.png)

### 状态

![image-20210727205959563](Images/image-20210727205959563.png)

### 转换/丁字裤模型

![image-20210727205926308](Images/image-20210727205926308.png)

### 组织方式

![image-20210727210023617](Images/image-20210727210023617.png)

![image-20210727210039038](Images/image-20210727210039038.png)

## 进程控制

![image-20210727212555858](Images/image-20210727212555858.png)

### 基本概念

进程控制就是要实现进程状态转换

> 为什么进程控制要用原语来实现：
>
> ![image-20210727212724429](Images/image-20210727212724429.png)

### 相关原语

1. 更新PCB中的信息 

   ​	a. 所有的进程控制原语一定都会修改进程状态标志 

   ​	b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境 

   ​	c. 某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列

3. 分配/回收资源

#### 创建

![image-20210727212815868](Images/image-20210727212815868.png)

#### 终止

![image-20210727212833100](Images/image-20210727212833100.png)

#### 阻塞、唤醒

![image-20210727212853260](Images/image-20210727212853260.png)

#### 切换

![image-20210727212930008](Images/image-20210727212930008.png)

#### 总览

![image-20210727213146915](Images/image-20210727213146915.png)

## 进程通信

![image-20210727215831262](Images/image-20210727215831262.png)

> 为什么进程通信需要操作系统支持：
>
> 为了保证安全，一个进程不能直接访问另 一个进程的地址空间

### 共享存储

为了避免出错，各个进程对共享空间的==访问==是==互斥==的

![image-20210727215959491](Images/image-20210727215959491.png)

### 消息传递

![image-20210727220112174](Images/image-20210727220112174.png)

#### 直接通信

![image-20210727220144519](Images/image-20210727220144519.png)

#### 间接通信

![image-20210727220216219](Images/image-20210727220216219.png)

### 管道通信

![image-20210727220232998](Images/image-20210727220232998.png)

> 写进程往管道写数据，即便管道没被写满，==只要管道没空，读进程就可以从管道读数据==
>
> 读进程从管道读数据，即便管道没被读空，==只要管道没满，写进程就可以往管道写数据==

## 线程的概念与特点

### 为什么要引入线程

![image-20210727221143006](Images/image-20210727221143006.png)

![image-20210727221204314](Images/image-20210727221204314.png)

### 引入线程带来的变化

![image-20210727221229547](Images/image-20210727221229547.png)

### 线程的属性

![image-20210727221247318](Images/image-20210727221247318.png)

### 线程的实现方式

![image-20210727222553202](Images/image-20210727222553202.png)

#### 用户级线程

![image-20210727222624922](Images/image-20210727222624922.png)

#### 内核级线程

![image-20210727222658866](Images/image-20210727222658866.png)

### 多线程模型

#### 一对一

![image-20210727222726849](Images/image-20210727222726849.png)

#### 多对一

![image-20210727222757077](Images/image-20210727222757077.png)

#### 多对多

![image-20210727222819297](Images/image-20210727222819297.png)

## 调度的概念

![image-20210730180413074](Images/image-20210730180413074.png)

> 简单理解：
>
> 高级调度：进程创建/销毁
>
> 中级调度：进程放到外存，放回内存
>
> 低级调度：进程分配处理机

![image-20210730180427063](Images/image-20210730180427063.png)

![image-20210730180440804](Images/image-20210730180440804.png)

## 进程调度

![image-20210730181704563](Images/image-20210730181704563.png)

### 进程调度的时机

![image-20210730181759331](Images/image-20210730181759331.png)

![image-20210730181741226](Images/image-20210730181741226.png)

### 进程调度的方式

![image-20210730181837722](Images/image-20210730181837722.png)

### 进程的切换与过程

![image-20210730181902659](Images/image-20210730181902659.png)

## 调度算法的评价指标

![image-20210731183411069](Images/image-20210731183411069.png)

> 所有周转时间都是越小越好

## 调度算法

![image-20210731190031893](Images/image-20210731190031893.png)

![image-20210731203620625](Images/image-20210731203620625.png)

### 先来先服务

![image-20210731190111709](Images/image-20210731190111709.png)

![image-20210731190140254](Images/image-20210731190140254.png)

### 短作业优先

![image-20210731190214469](Images/image-20210731190214469.png)

#### 抢占式

![image-20210731190238625](Images/image-20210731190238625.png)



#### 非抢占式

![image-20210731190438234](Images/image-20210731190438234.png)

![image-20210731190355567](Images/image-20210731190355567.png)

#### 注意

![image-20210731190504216](Images/image-20210731190504216.png)

### 高响应比优先

==FCFS 算法==是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对==短作业不友好==的问题

==SJF 算法==是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因 此导致了对==长作业不友好==的问题，甚至还会造成==饥饿问题==

高响应比优先既考虑到各个作业的等待时间，也兼顾运行时间



![image-20210731190559641](Images/image-20210731190559641.png)

![image-20210731190618658](Images/image-20210731190618658.png)

### 时间片轮转

![image-20210731203149241](Images/image-20210731203149241.png)

#### 时间片小

![image-20210731203216627](Images/image-20210731203216627.png)

![image-20210731203237897](Images/image-20210731203237897.png)

![image-20210731203255380](Images/image-20210731203255380.png)

#### 时间片大

![image-20210731203058399](Images/image-20210731203058399.png)

### 优先级调度

![image-20210731203331622](Images/image-20210731203331622.png)

![image-20210731203408641](Images/image-20210731203408641.png)

#### 非抢占式

![image-20210731203426971](Images/image-20210731203426971.png)

#### 抢占式

![image-20210731203458427](Images/image-20210731203458427.png)

### 多级反馈队列调度

![image-20210731203530195](Images/image-20210731203530195.png)

![image-20210731203556927](Images/image-20210731203556927.png)

## 进程同步、互斥

![image-20210731205508103](Images/image-20210731205508103.png)

### 同步

![image-20210731205526222](Images/image-20210731205526222.png)

### 互斥

![image-20210731205555524](Images/image-20210731205555524.png)

![image-20210731205611062](Images/image-20210731205611062.png)

![image-20210731205622454](Images/image-20210731205622454.png)